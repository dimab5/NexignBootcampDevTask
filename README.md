# Разработка – практическое задание Nexign Bootcamp
## 1) Структура приложения и схема взаимодействия сервисов
![Снимок экрана 2024-05-12 184824](https://github.com/dimab5/NexignBootcampDevTask/assets/113174105/095c00c8-c6d5-464a-b557-c67d295d4ba3)

[Общая схема.pdf](https://github.com/dimab5/NexignBootcampDevTask/files/15286999/FINAL.pdf) (то же самое файлом)

### В структрупе приложения были выделены 3 микросервиса, которые взаимодействуют через кафку:
1) [CdrGenerator](DevelopmentTask/CdrGenerator) - микросервис, который отвечает за генерацию "входных данных". Он генерирует Cdr данные, каждые 10 записывает в файл, записывает в базу данных, а также отправляет их в микросервис [Brt](DevelopmentTask/Brt) через кафку в топик `cdr_switch_to_brt`.
2) [Brt](DevelopmentTask/Brt) - микросервис, который авторизирует пользователей (проверяет, является ли пользователь абонентом "Ромашки") и снимает деньги с пользователей.
Brt читает данные из топика `cdr_switch_to_brt`, авторизирует абонентов, отправляет обновленные данные в микросервис [Hrs](DevelopmentTask/Hrs) через топик `cdr_enriched_brt_to_hrs`, получает обратно информацию о том, сколько денег нужно снять с абонентов и производит снятие денег с баланса.
3) [Hrs](DevelopmentTask/Hrs) - микросервис, который производит вычисления суммы, которую нужно списать с абонента, в соответствии с его тарифом. Hrs считывает из топика `cdr_enriched_brt_to_hrs` информацию о звонках, вычисляет длительность звонка и производит тарификацию. В топик `cost_hrs_to_brt` отправляются данные о сумме, которую нужно списать с абонентов, у которых классический тариф (нет помесячной платы, фиксированная стоимость минуты звонка). В топик `tariff_hrs_to_brt` отправляются данные о сумме, которую нужно списать с абонентов с помесяным тарифом.

## 2) Схемы баз данных
![image](https://github.com/dimab5/NexignBootcampDevTask/assets/113174105/f0f88c3e-7c04-49bc-b401-491f1c59037e)

[Схема баз данных.pdf](https://github.com/dimab5/NexignBootcampDevTask/files/15287065/ERD.final.pdf) (то же самое файлом)

### Описание:
Было принято логичное и рациональное решение создать собственную базу данных для каждого микросервиса, чтобы одно приложение (микросервис) был подключен и делал запросы ровно в одну бд. 
### Подробнее про структуру и сами таблицы:
1) Микросервис [CdrGenerator](DevelopmentTask/CdrGenerator) содержит базу данных, состоящую из двух таблиц. Таблица `clients` содержит всех существующих клиентов, которые будут учавствовать в звонках при их генерации. В таблицу `history` записываются все сгенерированные записи из cdr.
2) Микросервис [Brt](DevelopmentTask/Brt) содержит базу данных, состоящую из трех таблиц. Таблица `clients` содержит абонентов оператора "Ромашка". В таблицу `history` записываются пришедшие данные о звонках, но только абонентов оператора "Ромашка". Также таблица `history` содержит стоимость звонка и статус отправки стоимости из hrs (можно использовать эту таблицу для просмотра логов). В таблицу `tariff_payments_history' из записываются приходящие из [Hrs](DevelopmentTask/Hrs) данные о помесячных списаниях.
3) Микросервис [Hrs](DevelopmentTask/Hrs) содержит базу данных, состоящую из трех таблиц. Таблица `tariffs` содержит список всех существующих тарифов. Соответсвенно, если появится новый тариф его просто следует добавить в эту таблицу и записать правила тарификации в json в соответсвтии с его структурой (структура json с правилами тарификации также есть в сфеме таблицы). В таблицу `history` записывается история списаний. Таблица `traffic` нужна для хранения абонентов с помесячным тарифом для списания с этих абонентов определенной суммы в конце месяца (сумма прописана в таблице `tariffs` в tariff_rules). Также в ней хранится количество потраченных минут, чтобы знать, когда бесплатные минуты закончатся.

## 3) [Ссылка на Swagger](api.yaml)

## 4) Схема запуска сервисов в ручном режиме
1) Перед запуском сервисов требуется через докер запустить контейнеры: `zookeper`, `kafka`, `postgres_cdr`, `postgres_brt`, `postgres_hrs`.
2) После этого запустить сначала сервисы [Brt](DevelopmentTask/Brt), [Hrs](DevelopmentTask/Hrs), запустив соответствующие SpringBootApplication: 




